# äººè„¸è¡¨æƒ…è¯†åˆ«ï¼ˆå«æ¯è¡Œæ³¨é‡Šï¼‰
# Python + PyTorch + GPU
# ç”¨å·ç§¯ç¥ç»ç½‘ç»œï¼ˆCNNï¼‰è®­ç»ƒä¸€ä¸ªè¡¨æƒ…åˆ†ç±»å™¨
import os                                       # ç”¨äºä¸æ“ä½œç³»ç»Ÿäº¤äº’ï¼ˆæ–‡ä»¶è·¯å¾„ã€ç¯å¢ƒå˜é‡ç­‰ï¼‰
import torch                                    # PyTorch ä¸»åŒ…ï¼ŒåŒ…å«å¼ é‡ï¼ˆtensorï¼‰å’Œè®¡ç®—å›¾åŠŸèƒ½
import torch.nn as nn                           # ç¥ç»ç½‘ç»œæ¨¡å—ï¼ŒåŒ…å«å¸¸ç”¨å±‚ï¼ˆConvã€Linearã€ReLU ç­‰ï¼‰
import torch.optim as optim                     # ä¼˜åŒ–å™¨æ¨¡å—ï¼ŒåŒ…å« Adamã€SGD ç­‰ä¼˜åŒ–ç®—æ³•
from torchvision import datasets, transforms, models # torchvision æä¾›æ•°æ®é›†ã€å›¾åƒå˜æ¢å’Œé¢„è®­ç»ƒæ¨¡å‹ç­‰å·¥å…·
from torch.utils.data import DataLoader         # DataLoader ç”¨äºæŠŠ Dataset å˜æˆå¯è¿­ä»£çš„æ•°æ®åŠ è½½å™¨
import matplotlib.pyplot as plt                  # ç”¨äºç»˜å›¾ï¼Œç»˜åˆ¶è®­ç»ƒæ›²çº¿
from PIL import Image                            # ç”¨äºå›¾åƒè¯»å–ä¸å¤„ç†ï¼ˆPillow åº“ï¼‰

# ----------------------------------------------------------
# 1ï¸âƒ£ è®¾ç½®æ•°æ®é›†è·¯å¾„ï¼ˆæ”¹æˆä½ è‡ªå·±çš„è·¯å¾„ï¼‰
# ----------------------------------------------------------
train_dir = r"C:\Users\rog1\Desktop\äººè„¸è¡¨æƒ…è¯†åˆ«æ•°æ®é›†\archive\train"  # è®­ç»ƒé›†æ–‡ä»¶å¤¹è·¯å¾„ï¼Œæ³¨æ„ç”¨åŸå§‹å­—ç¬¦ä¸² r"..." æˆ– åŒæ–œçº¿
test_dir = r"C:\Users\rog1\Desktop\äººè„¸è¡¨æƒ…è¯†åˆ«æ•°æ®é›†\archive\test"    # æµ‹è¯•é›†æ–‡ä»¶å¤¹è·¯å¾„

# ----------------------------------------------------------
# 2ï¸âƒ£ å®šä¹‰å›¾åƒé¢„å¤„ç†æ–¹å¼ï¼ˆtransformsï¼‰
# transforms.Resize((48,48)) è¡¨ç¤ºæŠŠæ‰€æœ‰å›¾ç‰‡ç¼©æ”¾åˆ° 48x48 åƒç´ 
# transforms.ToTensor() æŠŠå›¾ç‰‡è½¬ä¸º PyTorch å¼ é‡
# transforms.Normalize() è®©æ¨¡å‹æ›´ç¨³å®š
# ----------------------------------------------------------
transform = transforms.Compose([               # Compose æŠŠå¤šä¸ªå˜æ¢æŒ‰é¡ºåºä¸²è”
    transforms.Resize((48, 48)),                # å°†å›¾ç‰‡ç¼©æ”¾åˆ° 48x48ï¼Œç¡®ä¿è¾“å…¥å°ºå¯¸ä¸€è‡´ï¼›å¦‚æœåŸå›¾ç°åº¦/å½©è‰²ä¸åŒï¼Œéœ€è¦æ³¨æ„é€šé“æ•°
    transforms.RandomHorizontalFlip(),          # éšæœºæ°´å¹³ç¿»è½¬ï¼ˆæ•°æ®å¢å¼ºï¼‰ï¼Œè®­ç»ƒæ—¶å¸¸ç”¨æ¥æå‡æ³›åŒ–
    transforms.RandomRotation(10),              # éšæœºæ—‹è½¬ Â±10Â°ï¼ˆæ•°æ®å¢å¼ºï¼‰ï¼Œèƒ½è®©æ¨¡å‹å¯¹å°è§’åº¦æ—‹è½¬æ›´é²æ£’
    transforms.ToTensor(),                      # æŠŠ PIL å›¾ç‰‡æˆ– ndarray è½¬ä¸ºå½¢çŠ¶ä¸º [C,H,W] çš„å¼ é‡ï¼Œå¹¶æŠŠåƒç´ å€¼å½’ä¸€åŒ–åˆ° [0,1]
    transforms.Normalize((0.5,), (0.5,))       # æ ‡å‡†åŒ–ï¼šå‡å‡å€¼é™¤ä»¥æ ‡å‡†å·®ï¼›è¿™é‡Œå‡è®¾å•é€šé“æˆ–è¿‘ä¼¼é€šé“å‡å€¼ä¸º 0.5ï¼Œä¾¿äºç½‘ç»œè®­ç»ƒ
])

# è¯´æ˜ï¼šå¦‚æœå›¾ç‰‡æ˜¯ RGBï¼ˆ3 é€šé“ï¼‰ï¼ŒNormalize éœ€è¦å†™æˆ Normalize((0.5,0.5,0.5),(0.5,0.5,0.5))

# ----------------------------------------------------------
# 3ï¸âƒ£ ä½¿ç”¨ ImageFolder è‡ªåŠ¨åŠ è½½æ•°æ®
# å®ƒä¼šæ ¹æ®å­æ–‡ä»¶å¤¹åå­—è‡ªåŠ¨ç”Ÿæˆæ ‡ç­¾
# ç›®å½•ç»“æ„åº”è¯¥ç±»ä¼¼ï¼štrain/0/*.jpg, train/1/*.jpg ...
# ----------------------------------------------------------
train_dataset = datasets.ImageFolder(train_dir,transform=transform)  # ImageFolder ä¼šæŠŠæ¯ä¸ªå­æ–‡ä»¶å¤¹å½“æˆä¸€ä¸ªç±»åˆ«
test_dataset = datasets.ImageFolder(test_dir,transform=transform)    # æµ‹è¯•é›†åŒç†

# ----------------------------------------------------------
# 4ï¸âƒ£ åˆ›å»ºæ•°æ®åŠ è½½å™¨ï¼ˆDataLoaderï¼‰
# batch_size = 64 è¡¨ç¤ºæ¯æ¬¡è®­ç»ƒè¯»å– 64 å¼ å›¾ç‰‡
# shuffle=True è¡¨ç¤ºæ‰“ä¹±è®­ç»ƒæ•°æ®é¡ºåº
# ----------------------------------------------------------
train_loader = DataLoader(train_dataset,batch_size = 64,shuffle = True)   # è®­ç»ƒæ—¶é€šå¸¸æ‰“ä¹±æ•°æ®ï¼Œä¾¿äºä¼˜åŒ–å™¨æ›´å¥½åœ°æ”¶æ•›
test_loader = DataLoader(test_dataset,batch_size = 64,shuffle = False)    # æµ‹è¯•æ—¶ä¸éœ€è¦æ‰“ä¹±ï¼Œæ–¹ä¾¿ç»“æœå¤ç°

print("ç±»åˆ«åˆ—è¡¨",train_dataset.classes)       # æ‰“å°ç±»åˆ«åç§°åˆ—è¡¨ï¼ˆç”±å­æ–‡ä»¶å¤¹åå†³å®šï¼‰
print("è®­ç»ƒæ ·æœ¬æ•°é‡",len(train_dataset))      # æ‰“å°è®­ç»ƒé›†æ ·æœ¬æ€»æ•°
print("æµ‹è¯•æ ·æœ¬æ•°é‡",len(test_dataset))        # æ‰“å°æµ‹è¯•é›†æ ·æœ¬æ€»æ•°

# ----------------------------------------------------------
# 5ï¸âƒ£ æ£€æŸ¥æ˜¯å¦å¯ä»¥ä½¿ç”¨ GPUï¼ˆCUDAï¼‰
# ----------------------------------------------------------
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")  # å¦‚æœ GPU å¯ç”¨åˆ™ä½¿ç”¨ cudaï¼Œå¦åˆ™ä½¿ç”¨ cpu
print("ä½¿ç”¨è®¾å¤‡:", device)                      # è¾“å‡ºå½“å‰ä½¿ç”¨çš„è®¾å¤‡ï¼Œæ–¹ä¾¿è°ƒè¯•

# ----------------------------------------------------------
# 6ï¸âƒ£ å®šä¹‰ä¸€ä¸ªç®€å•çš„ CNN æ¨¡å‹ï¼ˆç±»ä¼¼ LeNetï¼‰
# nn.Sequential ç”¨æ¥å¿«é€Ÿæ­å»ºç½‘ç»œç»“æ„
# ----------------------------------------------------------
class SimpleCNN(nn.Module):                      # å®šä¹‰ä¸€ä¸ªç»§æ‰¿è‡ª nn.Module çš„ç¥ç»ç½‘ç»œç±»
    def __init__(self,num_classes):              # æ„é€ å‡½æ•°ï¼Œnum_classes è¡¨ç¤ºåˆ†ç±»æ•°é‡ï¼ˆç±»åˆ«æ•°ï¼‰
        super().__init__()         # è°ƒç”¨çˆ¶ç±»æ„é€ å‡½æ•°ï¼Œå¿…è¦å†™æ³•
        self.network = nn.Sequential(            # ä½¿ç”¨ Sequential è¿ç»­å †å ç½‘ç»œå±‚ï¼Œä¾¿äºä¹¦å†™ç®€å•ç½‘ç»œ
            nn.Conv2d(3, 32, kernel_size = 3, padding = 1),  # å·ç§¯å±‚ï¼šè¾“å…¥é€šé“ 3 (RGB)ï¼Œè¾“å‡ºé€šé“ 32ï¼Œ3x3 å·ç§¯ï¼Œpadding=1 ä¿æŒå°ºå¯¸
            nn.ReLU(),                            # æ¿€æ´»å‡½æ•° ReLUï¼ˆå¼•å…¥éçº¿æ€§ï¼‰
            nn.MaxPool2d(2,2),                   # æœ€å¤§æ± åŒ–ï¼šçª—å£ 2x2ï¼Œæ­¥é•¿ 2ï¼Œå°ºå¯¸å‡åŠ

            nn.Conv2d(32,64,kernel_size = 3, padding = 1),  # ç¬¬äºŒä¸ªå·ç§¯å±‚ï¼š32->64 é€šé“
            nn.ReLU(),                            # å†æ¬¡ä½¿ç”¨ ReLU
            nn.MaxPool2d(2,2),                   # å†æ¬¡æ± åŒ–ï¼Œå°ºå¯¸å†æ¬¡å‡åŠ

            nn.Flatten(),  #å±•å¹³æˆä¸€ç»´å‘é‡ï¼Œä¾›å…¨è¿æ¥å±‚ä½¿ç”¨
            nn.Linear(64*12*12,128),             # å…¨è¿æ¥å±‚ï¼šè¾“å…¥ç‰¹å¾æ•° = é€šé“æ•° * é«˜ * å®½ï¼ˆè¿™é‡Œå‡è®¾è¾“å…¥ 48x48ï¼Œç»ä¸¤æ¬¡ 2x2 æ± åŒ–åå˜æˆ 12x12ï¼‰
            nn.ReLU(),                            # ReLU æ¿€æ´»
            nn.Linear(128,num_classes)           # è¾“å‡ºå±‚ï¼šå°† 128 ç»´æ˜ å°„ä¸º num_classes å¤§å°çš„ logitsï¼ˆæœªå½’ä¸€åŒ–åˆ†æ•°ï¼‰
        )

    def forward(self,x):                         # å®šä¹‰å‰å‘ä¼ æ’­ï¼ˆç½‘ç»œå¦‚ä½•ä»è¾“å…¥ç”Ÿæˆè¾“å‡ºï¼‰
        return self.network(x)                   # ç›´æ¥è°ƒç”¨ Sequential ä¸­å®šä¹‰çš„ç½‘ç»œç»“æ„
# ----------------------------------------------------------
# 7ï¸âƒ£ å®ä¾‹åŒ–æ¨¡å‹
# len(train_dataset.classes) ä¼šè‡ªåŠ¨è·å–ç±»åˆ«æ•°é‡
# ----------------------------------------------------------
model = SimpleCNN(num_classes = len(train_dataset.classes)).to(device)  # åˆ›å»ºæ¨¡å‹å®ä¾‹å¹¶æŠŠå®ƒç§»åŠ¨åˆ°æŒ‡å®šè®¾å¤‡ï¼ˆGPU/CPUï¼‰

# ----------------------------------------------------------
# 8ï¸âƒ£ å®šä¹‰æŸå¤±å‡½æ•°ä¸ä¼˜åŒ–å™¨
# CrossEntropyLossï¼šå¤šåˆ†ç±»å¸¸ç”¨çš„æŸå¤±å‡½æ•°
# Adamï¼šä¸€ç§å¸¸ç”¨çš„ä¼˜åŒ–ç®—æ³•
# ----------------------------------------------------------
criterion = nn.CrossEntropyLoss()               # äº¤å‰ç†µæŸå¤±ï¼Œé€‚ç”¨äºå¤šç±»åˆ†ç±»ï¼Œè¦æ±‚æ¨¡å‹è¾“å‡ºæœªç»è¿‡ softmax çš„ logits
optimizer = optim.Adam(model.parameters(), lr = 0.001)  # Adam ä¼˜åŒ–å™¨ï¼Œå­¦ä¹ ç‡ lr=0.001 æ˜¯åˆå§‹å¸¸ç”¨å€¼

# ----------------------------------------------------------
# 9ï¸âƒ£ å¼€å§‹è®­ç»ƒå¾ªç¯
# ----------------------------------------------------------
num_epochs = 45                                 # è®­ç»ƒè½®æ•°ï¼ˆå¯¹äºå°æ•°æ®é›†æˆ–è°ƒè¯•å¯ä»¥å‡å°ï¼‰
train_losses = []  # è®°å½•æ¯è½®è®­ç»ƒçš„å¹³å‡æŸå¤±
train_accuracies = []  # è®°å½•æ¯è½®è®­ç»ƒçš„å‡†ç¡®ç‡

for epoch in range(num_epochs):                  # è¿­ä»£æ¯ä¸€ä¸ª epoch
    model.train()                                # åˆ‡æ¢åˆ°è®­ç»ƒæ¨¡å¼ï¼ˆå¯ç”¨ dropoutã€batchnorm çš„è®­ç»ƒè¡Œä¸ºï¼Œå¦‚æœæœ‰çš„è¯ï¼‰
    running_loss = 0                             # ç”¨äºç´¯è®¡æ¯ä¸ª batch çš„æŸå¤±
    correct = 0                                  # ç´¯è®¡é¢„æµ‹æ­£ç¡®çš„æ ·æœ¬æ•°
    total = 0                                    # ç´¯è®¡æ ·æœ¬æ€»æ•°

    for images, labels in train_loader:          # éå†è®­ç»ƒé›†çš„æ¯ä¸ª batchï¼›images å½¢çŠ¶ [B, C, H, W]ï¼Œlabels å½¢çŠ¶ [B]
        images, labels = images.to(device), labels.to(device)  # æŠŠæ•°æ®ç§»åŠ¨åˆ° GPU/CPU

        optimizer.zero_grad()                    # æ¸…ç©ºä¸Šä¸€æ­¥è®¡ç®—çš„æ¢¯åº¦ï¼ˆå¾ˆé‡è¦ï¼Œå¦åˆ™æ¢¯åº¦ä¼šç´¯ç§¯ï¼‰
        outputs = model(images)                  # å‰å‘ä¼ æ’­ï¼šå¾—åˆ°æ¯ä¸ªæ ·æœ¬å¯¹æ¯ä¸ªç±»åˆ«çš„é¢„æµ‹åˆ†æ•°ï¼ˆlogitsï¼‰
        loss = criterion(outputs, labels)        # è®¡ç®—å½“å‰ batch çš„æŸå¤±ï¼ˆCrossEntropyLoss ä¼šæŠŠ logits å’Œ labels åš softmax+è´Ÿå¯¹æ•°ä¼¼ç„¶ï¼‰
        loss.backward()                          # åå‘ä¼ æ’­ï¼šè®¡ç®—å‚æ•°çš„æ¢¯åº¦
        optimizer.step()                         # ä¼˜åŒ–å™¨æ ¹æ®æ¢¯åº¦æ›´æ–°æ¨¡å‹å‚æ•°

        running_loss += loss.item()              # .item() å°†æ ‡é‡ tensor è½¬ä¸º Python æ•°å€¼ï¼Œç´¯åŠ æŸå¤±ä¾¿äºåç»­æ±‚å¹³å‡
        _, predicted = torch.max(outputs, 1)     # torch.max è¿”å›æœ€å¤§å€¼å’Œç´¢å¼•ï¼Œæˆ‘ä»¬å–ç´¢å¼•ï¼ˆé¢„æµ‹çš„ç±»åˆ«ï¼‰
        total += labels.size(0)                  # labels.size(0) æ˜¯å½“å‰ batch çš„æ ·æœ¬æ•°ï¼Œç´¯åŠ åˆ°æ€»æ ·æœ¬æ•°
        correct += (predicted == labels).sum().item()  # ç»Ÿè®¡é¢„æµ‹æ­£ç¡®çš„æ ·æœ¬æ•°å¹¶ç´¯åŠ 

    avg_loss = running_loss / len(train_loader)  # è®¡ç®—æœ¬è½®çš„å¹³å‡æŸå¤±ï¼ˆæŒ‰ batch å¹³å‡ï¼‰
    train_acc = 100 * correct / total            # è®¡ç®—è®­ç»ƒå‡†ç¡®ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
    train_losses.append(avg_loss)                # è®°å½•æŸå¤±æ›²çº¿ç”¨æ•°æ®
    train_accuracies.append(train_acc)           # è®°å½•å‡†ç¡®ç‡æ›²çº¿ç”¨æ•°æ®

    print(f"Epoch [{epoch+1}/{num_epochs}] | Loss: {avg_loss:.4f} | Train Acc: {train_acc:.2f}%")  # æ‰“å°è®­ç»ƒä¿¡æ¯

# ----------------------------------------------------------
# ğŸ”Ÿ ç»˜åˆ¶è®­ç»ƒè¿‡ç¨‹æ›²çº¿
# ----------------------------------------------------------
plt.figure(figsize=(10,4))                       # åˆ›å»ºä¸€ä¸ªå›¾å½¢çª—å£ï¼Œè®¾ç½®å¤§å°

# å­å›¾1: æŸå¤±æ›²çº¿
plt.subplot(1,2,1)                               # åœ¨ä¸€è¡Œä¸¤åˆ—çš„å­å›¾ä¸­é€‰æ‹©ç¬¬ 1 ä¸ªä½ç½®
plt.plot(train_losses, label="Training Loss")    # ç»˜åˆ¶æŸå¤±æ›²çº¿ï¼ˆX è½´ä¸º epoch ç´¢å¼•ï¼ŒY è½´ä¸ºæŸå¤±ï¼‰
plt.xlabel("Epoch")                             # X è½´æ ‡ç­¾
plt.ylabel("Loss")                              # Y è½´æ ‡ç­¾
plt.title("Training Loss Curve")                # å­å›¾æ ‡é¢˜
plt.legend()                                      # æ˜¾ç¤ºå›¾ä¾‹

# å­å›¾2: å‡†ç¡®ç‡æ›²çº¿
plt.subplot(1,2,2)                               # é€‰æ‹©ç¬¬ 2 ä¸ªå­å›¾ä½ç½®
plt.plot(train_accuracies, label="Training Accuracy")  # ç»˜åˆ¶å‡†ç¡®ç‡æ›²çº¿
plt.xlabel("Epoch")                             # X è½´æ ‡ç­¾
plt.ylabel("Accuracy (%)")                      # Y è½´æ ‡ç­¾
plt.title("Training Accuracy Curve")            # å­å›¾æ ‡é¢˜
plt.legend()                                      # æ˜¾ç¤ºå›¾ä¾‹

plt.tight_layout()                                # è‡ªåŠ¨è°ƒæ•´å­å›¾é—´è·ï¼Œé˜²æ­¢é‡å 
plt.show()                                        # æ˜¾ç¤ºå›¾å½¢

# è¯´æ˜ä¸å»ºè®®ï¼š
# 1) å¦‚æœä½ çš„å›¾ç‰‡æ˜¯ç°åº¦å›¾ï¼ˆå•é€šé“ï¼‰ï¼Œéœ€è¦æŠŠæ¨¡å‹çš„ç¬¬ä¸€ä¸ª Conv2d çš„ in_channels ä» 3 æ”¹ä¸º 1ï¼Œ
#    å¹¶æŠŠ Normalize çš„å‚æ•°è°ƒæ•´ä¸ºå•é€šé“ï¼šNormalize((0.5,), (0.5,))ï¼ˆæœ¬ä»£ç å·²ä½¿ç”¨è¯¥ Normalizeï¼Œä½† Conv2d å‡è®¾ RGBï¼‰ã€‚
# 2) è‹¥é‡åˆ°ç»´åº¦ä¸åŒ¹é…ï¼ˆå¦‚ Linear çš„è¾“å…¥å¤§å°ä¸å¯¹ï¼‰ï¼Œå¯é€šè¿‡æ‰“å°ç‰¹å¾å›¾å½¢çŠ¶ï¼ˆåœ¨ forward ä¸­ï¼‰æ¥è°ƒè¯•ï¼š
#    åœ¨ forward ä¸­æ·»åŠ æ‰“å°è¯­å¥æˆ–åœ¨è®­ç»ƒå‰ç”¨å•ä¸ªæ ·æœ¬æµ‹è¯• model(torch.randn(1,3,48,48)) çœ‹è¾“å‡ºå½¢çŠ¶ã€‚
# 3) è®­ç»ƒæ—¶å¯åŠ å…¥éªŒè¯ï¼ˆvalidationï¼‰å¾ªç¯ï¼Œç”¨ test_loader åœ¨æ¯ä¸ª epoch åè¯„ä¼°æ¨¡å‹åœ¨éªŒè¯é›†ä¸Šçš„æ€§èƒ½å¹¶ä¿å­˜æœ€ä¼˜æ¨¡å‹ã€‚
# 4) å­¦ä¹ ç‡ã€batch_sizeã€ç½‘ç»œæ·±åº¦ç­‰è¶…å‚æ•°å¯¹ç»“æœå½±å“å¾ˆå¤§ï¼Œå¯æ ¹æ®æ•°æ®é›†å¤§å°å’Œè®¡ç®—èµ„æºè°ƒæ•´ã€‚
